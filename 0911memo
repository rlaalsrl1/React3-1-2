파이프라인은 공식적으로 채택되지 않은 연산자이기 때문에 
기능을 사용하려면 바벨 플러그인을 설치해야 함
설치 코드)npm i --save-dev @babel/plugin-proposal-pipeline-operator @babel/core
그 후 .babelrc 파일을 수정
{
    "presets":["next/babel"],
    "plugins":[
        [
           @babel/plugin-proposal-pipeline-operator 
           ?
        ]
    ]
}

개발 시 타입스크립트를 주 언어로 쓰고 싶다면 타입스크립트 전용 플러그인을 설치하고 설정 바꾸기
-->프로젝트 생성시 선택 가능하기 떄문에 생성할 때 설정 할 것!

웹팩은 특정 라이브러리, 페이지, 기능에 대해 컴파일된 코드를 전부 포함하는 번들을 만들어 줌
만약 SASS나 LESS 같은 CSS 전처리기를 사용해서 개발하고 싶다면. 웹팩 설정을 수정해 주면 됨

처음에 Next 프로젝트를 생성할 때 오류로 생성되진 않는 경우가 있음
이 것은 CRA가 설치되어 있지 않아서 생기는 현상으로
create-react-app 을 Global로 설치해 주면 됨
$npmi-g create-react-app
이후 프로젝트를 생성
$npx create-next-app@latest

Next.js 12이후 babel의 지원이 중지되고 SWC로 그 기능이 대체됨
그렇기에 최신 버전에서 babel은 오류가 남

Transpile은 어떻게 동작하나
babel은 ECMAScript와 같은 자바스크립트 최신버전이나, TypeScript를 이전 버전의 코드로
변환시켜주는 Transpile 도구임
개발자가 작성한 코드 -> Parse -> Transform ->Generate ->이전 버전의 코드
Babel의 parser는 잡바스크립트를 컴퓨터가 이해할 수 있는 코드 구조인 Abstract Syntax Tree(AST)
로 변환해 주는 역할을 수행
Babel의 traverse모듈은 전체 트리상태(AST)를 유지하며 노드 교체, 제거, 추가를 담당함
마지막 generator가 수정된 ASt를 일반 코드로 변환해 줌

SWC도 Babel과 같은 자바스크립트 트랜스 컴파일러임
Next 12 이후 부터 Babel에서 SWC로 교체됨
SWC는 Rust로 작성되어 있어 Babel에 비해서 속도가 훨씬 빠름

Babel의 단점
1.Babel로 변환된 코드를 이해하기 어려움
2.원 코드에 비해 변환코드의 길이가 늘어남
3.변환에 시간이 많이 걸림

SWC의 장점
1.Next 12이후 별도의 설정 없이 SWC를 사용 가능(Next.js에 내장)
2.변환 속도가 빠름
3.
4.

-서버 사이드 렌더링(SSR)
웹 페이지를 제공하는 가장 흔한 방법
APM을 이용하는 일반적인 웹 페이지 생성
여기에 자바스크립트 코드가 적재되면 동적으로 페이지내용을 렌더링함

Next.js 도 이와 같이 동적으로 페이지를 렌더링할 수 있음
그리고 여기에 스크립트 코드를 집어 넣어서 나중에 웹 페이지를 동적으로 처리할 수도 있는데
이를 -하이드레이션-이라고 함

ex)어떤 사람이 작성한 블로그 글을 한 페이지에 모아서 작성해야 한다면 SSR을 이용하는 것이 적당함
서버사이드 렌더링-> 자바스크립트가 하이드레이션된 페이지를 전송-> 클라이언트에서 DOM 위에
각 스크립트 코드를 하이드레이션:페이지 새로고침 없이 사용자와 웹 페이지간 상호 작용을 가능하게 함

리액트 하이드레이션 덕분에 이 상태에서 웹 앱은 싱글 페이지 애플리케이션(SPA)처럼 작동할 수 있음
CSR과 SSR의 장점을 모두 가지는 것
특정 렌더링 전략만 사용한다면 SSR이 CSR에 비해 여러 장정이 있음
[SSR의 장점]
더 안전한 웹 애플리케이션: 쿠키관리 ,주요API, 데이터 검증 등과 같은 작업을 서버에서 처리하기때문에 중요한
데이터를 클라이언트에게 노출할 필요가 없음
더 뛰어난 웹사이트 호환성:클라이언트 환경이 자바스크립트를 사용하지 못하거나 오래된 브라우저를 사용하더라도
서비스를 제공할 수 있음
더 뛰어난 SEO: 서버가 렌더링한 HTML을 받기 떄문에 봇이나 웹 크롤러가 페이지를 렌덩링할 필요가 없음

SSR이 최적의 렌더링 전략이 아닌 경우
-클라이언트가 페이지를 요청할 때마다 다시 렌더링할 수 있는 서버가 필요
-다른 방식에 비해 SSR이 더 많은 자원을 소모, 더 많은 부하를 보이며 유지 보수 비용도 증가함
-페이지에 대한 요청을 처리하는 시간이 길어짐
-페이지가 외부 API 또는 데이터 소스에 접근해야 한다면, 해당 페이지를 렌더링 할 때마다 이를
다시 요청해야함
-페이지 간의 이동은 CSR에 비해 느림

-중요한건은 Next-js 가 기본적으로 빌드 시점에 정적으로 페이지를 만든다는 것.
-페이지에서 외부 API를 호출하거나 데이터베이스에 접근하는 등 동적 작업을 해야한다면 해당하는 
함수를 페이지에 export해야 합니다.


페이지에 대한 요청이 들어오면 서버가 REST API를 호출해서 필요한 사용자 정보를 가져옵니다.

세부과정
1. getServerSideProps라는 비동기 함수를 export함
빌드 과정에서 Next.js는 이 함수를 export하는 모든 페이지를 찾아서 서버가 페이지 요청을 처리할 때
getServerSideProps 함수를 호출하도록 만듬
2.getServerSideProps함수는 props라는 속성값을 갖는 객체를 반환함
이 props는 컴포넌트로 전달되 서버와 클라이언트 모두가 props에 접근할 수 있게 됨
fetch API는 서버에서 실행되기 때문에 별도의 폴리피을 끼워 넣을 필요는 없음
3.IndexPage 함수를 수정해서 props를 인자로 받음


-클라이언트 사이드 렌더링(CSR)-
React 앱을 실행하면 렌더링 시작전 빈 화면이 한동안 유지 되는 것이 보임
이는 서버에서 스크립트와 스타일만 포함된 HTML을 전송하기 때문
실제 렌더링은 클라이언트에서 이루어짐
CSR로 생성한 앱의 HTML을 보면 div태그 하나 밖에 없음 그래서 빈 화면만 보임
빌드 과정에서 js 와 css 파일을 HTML페이지에 블러오도록 만들고 root div 에 렌더링 함

CSR을 사용할때의 이점
네이티브 앱 처럼 느껴지는 웹 앱
-전체 사바스크립트 번들을 다운로드 한다는 것은 렌더링 할 모든 페이지가 이미 브라우저에 다운되어 있다는 뜻
다른 페이지로 이동해도 서버에 요청할 필요없이 바로 페이지를 이동할 수있음, 새로 고칠 필요가 없음
쉬운 페이지 전환
-클라이언트에서의 내비게이션은 브라우저 화면을 새로 고칠 필요 없이 다른 페이지로의 이동을 가능하게 만듬
-애니메이션을 방해할 요소가 없기 때문에,페이지간 전환에 효과를 넣을수도 있음
지연된 로딩과 성능
-웹 앱은 최소로 필요한 HTML만 렌더링함
-버튼을 누르면 나오는 모달도 실제 버튼이 눌렸을 때 동적으로 생성하게 됨
서버 부하 감소
-서버리스 환경에서 웹 앱을 제공할 수도있음

-장점이 단점이 될 수도 있음-
네트워크 속도가 느린 환경에서는 번들이 모두 다운로드 될 때까지 계속 빈 페이지를 보아야 함
검색 로봇에게도 그 내용은 빈 것으로 보임
번들을 모두 받을 때까지 검색 로봇이 기다리기는 하지만 성능 점수는 낮을 것

React.useEffect Hook
최근 리액트는 함수형 컴포넌트 사용을 강조하면서 life cycle함수 대신 Hook을 사용함
함수형 컴포넌트 내에서 DOM조작이나 데이터 불러오기 같은 사이드 이펙트 기능을 구현할 때,
useEffect함수를 사용해서 컴포넌트가 마운트 된 후 해당 기능을 실행하도록 만들 수 있음 

process.browser 변수
서버에서 렌더링할 때 브라우저 전용 API로 인한 문제를 다른 방법으로 해결할 수도 있음
process.browser 값에 따라서 스크립트와 컴포넌트를 조건별로 실행하는 것
***지원 중단함, 일부에서만 사용***

좀 더 정확한 의미를 갖는 typeof window를 사용할 숭 있음
typeof window를 서버에서 실행하면 그 값은 문자열"undefined"가 되며,
 그렇지 않으면 클라이언트에서 실행됨

동적 컴포넌트 로딩 -dynamic
dynamic함수로도 React, useEffect 훅과 똑같이 동작할수 있음
Highlight 컴포넌트를 동적 임포트(dynamic import)로 불러옴
즉 SSR:false 옵션으로 클라이언트에서만 동작한다고 명시하는 것

정적 사이트 생성(SST:Static Site Generation)
SSG는 일부 또는 전체 페이지를 빌드 시점에 미리 렌더링 함
SSG는 SSR 및 CSR 과 비교했을 때 다음과 같은 장점이 있음
1.쉬운 확장
정적 페이지는 단순 HTML 파일이므로 CDN을 통해 파일을 제공하거나, 캐시에 저장하기 쉬움
2.뛰어난 성능
빌드 시점에 HTML페이지를 미리 렌더링 하기 때문에 페이지를 요청해도 클라이언트나 서버가 
무언가는 처리할 필요가 없음
3.더 안전한 API요청
외부 API를 호츌하거나, 데이터베이스에 접근하거나,보호해야 할 데이터에 접근할 일이 없음
필요한 모든 정보가 빌드 시점에 미리 페이지로 렌더링 되어 있기 때문

SSG는 높은 확장성과 뛰어난 성능을 보이는 프런트엔드 애플리케이션을 만들고 싶은때 가장 좋은 방법
한 가지 문제점은 일단 뒙페이지를 만들고 나면 다음 배포 전까지 내용이 변하지 않는다는 점
조금이라도 수정하려면 필요한 데이터를 가져와서 수정하고 다시 생성하는 과정을 반복해야함
이런 문제 때문에 나온 방법이 바로 "증분 정적 재생성(ISR:incremental Static Regeneration)"입니다.
예를 들어 동적 콘텐츠를 제공하지만 해당 콘텐츠 데이터를 로딩 하는데 시간이 오래 걸린다면,
SSG와 ISR을 함께 사용하여 문제를 해결 할 수 있음
많은 양의 데이터를 필요로 하는 복잡한 대시보드를 만든다면, 데이터를 불러오기 위한 REST API호출에 수 초가 소요됨
만일 데이터가 자주 변하지 않는다면 SSG와 ISR을 사용해서 데이터를 10분동안 캐싱할 수 있음

